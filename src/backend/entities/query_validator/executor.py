"""
Query Validator Executor for workflow integration.

This executor validates SQL queries generated by the query_builder before execution.
It performs syntax checks, allowlist validation, statement type verification,
and security checks.

Note: Do NOT use 'from __future__ import annotations' in this module.
The Agent Framework's @handler decorator validates WorkflowContext type annotations
at class definition time, which is incompatible with PEP 563 stringified annotations.
"""

import json
import logging
import re

from agent_framework import (
    Executor,
    WorkflowContext,
    handler,
)
from models import (
    SQLDraft,
    SQLDraftMessage,
)

logger = logging.getLogger(__name__)


# Hardcoded allowlist of tables
ALLOWED_TABLES = {
    "Application.Cities",
    "Application.People",
    "Purchasing.PurchaseOrders",
    "Purchasing.Suppliers",
    "Sales.CustomerCategories",
    "Sales.Customers",
    "Sales.InvoiceLines",
    "Sales.Invoices",
    "Sales.OrderLines",
    "Sales.Orders",
    "Warehouse.StockItemHoldings",
    "Warehouse.StockItems",
}

# Allowed schemas derived from tables
ALLOWED_SCHEMAS = {table.split(".")[0] for table in ALLOWED_TABLES if "." in table}

# SQL injection patterns to detect
SQL_INJECTION_PATTERNS = [
    r";\s*--",  # Comment after semicolon
    r"'\s*OR\s+'?\d+'?\s*=\s*'?\d+'?",  # ' OR '1'='1'
    r"'\s*OR\s+''='",  # ' OR ''='
    r"UNION\s+SELECT",  # UNION injection
    r"INTO\s+OUTFILE",  # File write attempt
    r"INTO\s+DUMPFILE",  # File write attempt
    r"LOAD_FILE",  # File read attempt
    r"xp_cmdshell",  # SQL Server command execution
    r"sp_executesql",  # Dynamic SQL execution
    r"EXEC\s*\(",  # Procedure execution
    r"EXECUTE\s*\(",  # Procedure execution
    r"@@version",  # Information disclosure
    r"INFORMATION_SCHEMA",  # Schema enumeration
    r"sys\.",  # System table access
    r"WAITFOR\s+DELAY",  # Time-based injection
    r"BENCHMARK\s*\(",  # Time-based injection (MySQL)
]

# Dangerous keywords that should not appear in SELECT queries
DANGEROUS_KEYWORDS = [
    "INSERT",
    "UPDATE",
    "DELETE",
    "DROP",
    "ALTER",
    "CREATE",
    "TRUNCATE",
    "EXEC",
    "EXECUTE",
    "GRANT",
    "REVOKE",
    "DENY",
    "BACKUP",
    "RESTORE",
    "SHUTDOWN",
    "DBCC",
]


def _check_syntax(sql: str) -> tuple[bool, list[str]]:
    """
    Basic syntax check for SQL query.

    This is a lightweight check - full parsing would require a SQL parser.

    Returns:
        Tuple of (is_valid, list of errors)
    """
    errors = []

    sql_stripped = sql.strip()

    # Must not be empty
    if not sql_stripped:
        errors.append("Query is empty")
        return False, errors

    # Basic bracket matching
    if sql_stripped.count("(") != sql_stripped.count(")"):
        errors.append("Unbalanced parentheses")

    # Basic quote matching (simple check)
    single_quotes = sql_stripped.count("'")
    if single_quotes % 2 != 0:
        errors.append("Unbalanced single quotes")

    # Should start with SELECT (case-insensitive)
    if not sql_stripped.upper().lstrip().startswith("SELECT"):
        errors.append("Query does not start with SELECT")

    return len(errors) == 0, errors


def _check_statement_type(sql: str) -> tuple[str, bool, list[str]]:
    """
    Check that the query is a single SELECT statement.

    Returns:
        Tuple of (statement_type, is_single_statement, list of violations)
    """
    violations = []
    sql_upper = sql.strip().upper()

    # Determine statement type
    if sql_upper.startswith("SELECT"):
        statement_type = "SELECT"
    elif sql_upper.startswith("INSERT"):
        statement_type = "INSERT"
    elif sql_upper.startswith("UPDATE"):
        statement_type = "UPDATE"
    elif sql_upper.startswith("DELETE"):
        statement_type = "DELETE"
    elif sql_upper.startswith("DROP"):
        statement_type = "DROP"
    elif sql_upper.startswith("CREATE"):
        statement_type = "CREATE"
    elif sql_upper.startswith("ALTER"):
        statement_type = "ALTER"
    else:
        statement_type = "UNKNOWN"

    if statement_type != "SELECT":
        violations.append(f"Statement type is {statement_type}, must be SELECT")

    # Check for multiple statements (semicolon followed by non-whitespace)
    # But allow semicolon at the very end
    sql_trimmed = sql.strip().rstrip(";").strip()
    if ";" in sql_trimmed:
        violations.append("Multiple statements detected (semicolon found within query)")
        return statement_type, False, violations

    return statement_type, True, violations


def _check_allowlist(sql: str) -> tuple[bool, list[str], list[str]]:
    """
    Check that all referenced tables are in the allowlist.

    Handles table aliases properly - e.g., FROM Purchasing.Suppliers s
    will recognize 's' as an alias, not treat 's.SupplierName' as a table.

    Returns:
        Tuple of (is_valid, violations, warnings)
    """
    violations = []
    warnings = []

    # Extract table references from FROM and JOIN clauses
    # Pattern: FROM/JOIN Schema.Table [AS] alias  or  FROM/JOIN Table [AS] alias
    # This captures the table name and optional alias
    table_with_alias_pattern = (
        r"(?:FROM|JOIN)\s+"
        r"([A-Za-z_][A-Za-z0-9_]*(?:\.[A-Za-z_][A-Za-z0-9_]*)?)"  # Table (possibly qualified)
        r"(?:\s+(?:AS\s+)?([A-Za-z_][A-Za-z0-9_]*))?"  # Optional alias
    )

    matches = re.findall(table_with_alias_pattern, sql, re.IGNORECASE)

    # Track aliases so we don't confuse alias.column with schema.table
    aliases: set[str] = set()
    tables_found: set[str] = set()

    for table, alias in matches:
        table_normalized = table.strip()
        tables_found.add(table_normalized)

        if alias:
            aliases.add(alias.strip().upper())

    # Validate each table against allowlist
    for table in tables_found:
        if "." in table:
            # Fully qualified table - check against allowlist
            if not any(t.upper() == table.upper() for t in ALLOWED_TABLES):
                violations.append(f"Table '{table}' is not in the allowlist")
        else:
            # Unqualified table name - add warning (but not a violation)
            # It might be a table that needs schema prefix
            warnings.append(f"Table '{table}' should be fully qualified (e.g., Schema.Table)")

    return len(violations) == 0, violations, warnings


def _check_security(sql: str) -> tuple[bool, list[str]]:
    """
    Check for SQL injection patterns and dangerous keywords.

    Returns:
        Tuple of (is_valid, list of violations)
    """
    violations = []

    # Check for dangerous keywords
    for keyword in DANGEROUS_KEYWORDS:
        # Look for keyword as a whole word
        pattern = r"\b" + keyword + r"\b"
        if re.search(pattern, sql, re.IGNORECASE):
            violations.append(f"Dangerous keyword detected: {keyword}")

    # Check for SQL injection patterns
    for pattern in SQL_INJECTION_PATTERNS:
        if re.search(pattern, sql, re.IGNORECASE):
            violations.append("Potential SQL injection pattern detected")
            break  # One is enough

    return len(violations) == 0, violations


class QueryValidatorExecutor(Executor):
    """
    Executor that validates SQL queries before execution.

    This executor:
    1. Receives SQLDraftMessage from the nl2sql_controller (after param_validator)
    2. Validates syntax, allowlist, statement type, and security
    3. Sets query_validated=True and populates query_violations/query_warnings
    4. Returns SQLDraftMessage back to nl2sql_controller
    """

    def __init__(self, executor_id: str = "query_validator") -> None:
        """
        Initialize the Query Validator executor.

        Args:
            executor_id: Executor ID for workflow routing
        """
        super().__init__(id=executor_id)
        logger.info(
            "QueryValidatorExecutor initialized with %d allowed tables", len(ALLOWED_TABLES)
        )

    @handler
    async def handle_validation_request(  # noqa: PLR6301
        self, request_msg: SQLDraftMessage, ctx: WorkflowContext[SQLDraftMessage]
    ) -> None:
        """
        Handle a query validation request.

        Args:
            request_msg: Wrapped JSON string containing SQLDraft
            ctx: Workflow context for sending the response
        """
        logger.info("QueryValidatorExecutor received validation request")

        # Emit step start event
        step_name = "Validating query"
        emit_step_end_fn = None
        try:
            from api.step_events import emit_step_end, emit_step_start

            emit_step_start(step_name)
            emit_step_end_fn = emit_step_end
        except ImportError:
            pass

        def finish_step() -> None:
            if emit_step_end_fn:
                emit_step_end_fn(step_name)

        try:
            # Parse the SQLDraft from the message
            draft_data = json.loads(request_msg.response_json)
            draft = SQLDraft.model_validate(draft_data)
            sql_query = draft.completed_sql or ""
            _ = draft.user_query  # Available for logging if needed

            logger.info("Validating query: %s", sql_query[:200] if sql_query else "(empty)")

            all_violations: list[str] = []
            all_warnings: list[str] = []

            # 1. Syntax check
            syntax_valid, syntax_errors = _check_syntax(sql_query)
            all_violations.extend(syntax_errors)

            # 2. Statement type and single statement check
            statement_type, is_single_statement, statement_violations = _check_statement_type(
                sql_query
            )
            all_violations.extend(statement_violations)

            # 3. Allowlist validation
            allowlist_valid, allowlist_violations, allowlist_warnings = _check_allowlist(sql_query)
            all_violations.extend(allowlist_violations)
            all_warnings.extend(allowlist_warnings)

            # 4. Security checks
            security_valid, security_violations = _check_security(sql_query)
            all_violations.extend(security_violations)

            # Overall validity
            is_valid = (
                syntax_valid
                and allowlist_valid
                and statement_type == "SELECT"
                and is_single_statement
                and security_valid
            )

            # Update the draft with validation results
            draft.query_validated = True
            draft.query_violations = all_violations
            draft.query_warnings = all_warnings

            logger.info(
                "Validation complete: valid=%s, violations=%d, warnings=%d",
                is_valid,
                len(all_violations),
                len(all_warnings),
            )

        except Exception as e:
            logger.exception("Validation error")
            # Parse the draft to preserve data, mark as validated with error
            try:
                draft_data = json.loads(request_msg.response_json)
                draft = SQLDraft.model_validate(draft_data)
            except Exception:  # noqa: BLE001
                # If we can't parse, create minimal draft with dynamic source as fallback
                draft = SQLDraft(
                    status="error",
                    source="dynamic",
                    user_query="",
                )
            draft.query_validated = True
            draft.query_violations = [f"Validation error: {e!s}"]
            draft.query_warnings = []

        finish_step()

        # Send the updated draft back
        response_msg = SQLDraftMessage(
            source="query_validator", response_json=draft.model_dump_json()
        )
        await ctx.send_message(response_msg)
